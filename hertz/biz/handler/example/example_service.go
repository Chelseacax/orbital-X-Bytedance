// Code generated by hertz generator.

package example

import (
	"context"
	"encoding/json"
	"fmt"
	"orbital/hertz/biz/model/example"

	// required for hertz to work
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"

	// required for kitex client & generic call feature
	"github.com/cloudwego/kitex/client"
	"github.com/cloudwego/kitex/client/genericclient"
	"github.com/cloudwego/kitex/pkg/generic"
	"github.com/cloudwego/kitex/pkg/klog"

	// required for load-balancing
	"github.com/cloudwego/kitex/pkg/loadbalance"
)

// Load Balancing options
var lb = loadbalance.NewWeightedRandomBalancer()
var server0 = "0.0.0.0:8888"
var server1 = "0.0.0.0:8889"

// HelloMethod .
// @router /hello [GET]
func HelloMethod(ctx context.Context, c *app.RequestContext) {

	var err error
	// evluating query string (in URL)
	var req example.HelloReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	fmt.Println("Passing " + req.Name + " request to Kitex")

	// Kitex's generic call feature
	// path is the location of the thrift file
	path := "../idl/example.thrift"
	p, err := generic.NewThriftFileProvider(path)
	if err != nil {
		klog.Fatalf("new thrift file provider failed: %v", err)
	}
	g, err := generic.JSONThriftGeneric(p)
	if err != nil {
		klog.Fatalf("new map thrift generic failed: %v", err)
	}

	// "example" is the service name
	cli, err := genericclient.NewClient("example", g,
		client.WithHostPorts(server0, server1),
		client.WithLoadBalancer(lb))
	if err != nil {
		klog.Fatalf("new http generic client failed: %v", err)
	}

	// "HelloMethod" is the method name
	resp, err := cli.GenericCall(context.Background(), "HelloMethod", `{"Name": "Hertz to Kitex"}`)

	// resp is a JSON string
	// type: interface{}
	// converting resp to string (interface{} --> string)
	s := resp.(string)

	// Unmarshalling of JSON string into Response struct (string --> Response struct)
	var response Response
	err = json.Unmarshal([]byte(s), &response)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	// Printing on Kitex client / Hertz server
	fmt.Println("Back in Hertz", req.Name)

	// Printing on Hertz client
	reply := utils.H{response.Response: req.Name}
	c.JSON(consts.StatusOK, reply)
}

// Add .
// @router /add [POST]
func Add(ctx context.Context, c *app.RequestContext) {

	fmt.Println("Passing to Kitex")

	var err error
	var req example.Variable
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// kitex's generic call feature
	path := "../idl/example.thrift"
	p, err := generic.NewThriftFileProvider(path)
	if err != nil {
		klog.Fatalf("new thrift file provider failed: %v", err)
	}
	g, err := generic.JSONThriftGeneric(p)
	if err != nil {
		klog.Fatalf("new map thrift generic failed: %v", err)
	}

	// "example" is the service name
	cli, err := genericclient.NewClient("example", g,
		client.WithHostPorts(server0, server1),
		client.WithLoadBalancer(lb))
	if err != nil {
		klog.Fatalf("new http generic client failed: %v", err)
	}

	// constructing struct for the JSON data (retrived as integers)
	var variables Variable
	variables = Variable{
		FirstInt:  req.FirstInt,
		SecondInt: req.SecondInt,
	}

	// Marhsalling the integers into jsonData (variable struct{int64, int64} --> []byte)
	jsonData, err := json.Marshal(variables)
	if err != nil {
		fmt.Println("Error:", err)
	}

	// "Add" is the method name
	// the string method changes []byte into inteface{} based on ASCII
	resp, err := cli.GenericCall(context.Background(), "Add", string(jsonData))

	// Unmarshalling of JSON string into Summer struct (string --> Summer struct)
	s := resp.(string)
	var answer Summer
	err = json.Unmarshal([]byte(s), &answer)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	fmt.Println("Passing results back")

	ans := utils.H{"The answer is": answer.Sum}
	c.JSON(consts.StatusOK, ans)
}

type Response struct {
	Response string `json:"RespBody"`
}

type Variable struct {
	FirstInt  int64 `json:"FirstInt"`
	SecondInt int64 `json:"SecondInt"`
}

type Summer struct {
	Sum int64 `json:"Sum"`
}
