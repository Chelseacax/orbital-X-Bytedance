// Code generated by hertz generator.

package orbital

import (
	"context"
	"encoding/json"
	"fmt"

	orbital "test1/hertz/biz/model/orbital"

	// For Hertz's framework
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"

	// For Kitex's client framework
	"github.com/cloudwego/kitex/client"

	// For Kitex's generic call feature
	"github.com/cloudwego/kitex/client/genericclient"
	"github.com/cloudwego/kitex/pkg/generic"
	"github.com/cloudwego/kitex/pkg/generic/thrift"
	"github.com/cloudwego/kitex/pkg/klog"

	// For service discovery & registry
	etcd "github.com/kitex-contrib/registry-etcd"
)

// Load balancing options --> declared in the other service file (i.e. calculator_service.go)
// Servers & their IP addresses that the microservers will be running on
var helloServer0 = "127.0.0.1:43000"
var helloServer1 = "127.0.0.1:43001"

// HelloMethod .
// @router /hello [GET]
func HelloMethod(ctx context.Context, c *app.RequestContext) {

	var err error

	// Evaluating query string in the URL
	var req orbital.HelloRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	klog.Info("HERTZ: Passing to Kitex")

	// Kitex's generic call feature

	// path is the pathway to the IDL file
	path := "../idl/orbital.thrift"

	// This function call will change the default IDL parsing
	// from only last service to all services in the IDL file.
	// By default (i.e. w/o this func call),
	// the parser will only parse the last service declared in the IDL file.
	thrift.SetDefaultParseMode(thrift.CombineServices)

	p, err := generic.NewThriftFileProvider(path)
	if err != nil {
		klog.Fatalf("New thrift file provider failed: %v", err)
	}

	g, err := generic.JSONThriftGeneric(p)
	if err != nil {
		klog.Fatalf("New map thrift generic failed: %v", err)
	}

	// Service discovery

	// This HTTP server (in Hertz) will run into an error
	// if the calculator microservice servers (in Kitex) are not up.
	r, err := etcd.NewEtcdResolver([]string{"127.0.0.1:2379"})
	if err != nil {
		klog.Fatalf("Service registry failed: %v", err)
	}

	// "hello" is the service name
	cli, err := genericclient.NewClient("hello", g,
		client.WithHostPorts(helloServer0, helloServer1),
		client.WithLoadBalancer(lb),
		client.WithResolver(r))
	if err != nil {
		klog.Fatalf("New HTTP generic client failed: %v", err)
	}

	// "HelloMethod" is the method name
	// The last variable is not used in the function
	resp, err := cli.GenericCall(context.Background(), "HelloMethod", `{"Not": "Used"}`)

	// resp is a JSON string
	// type: interface{}
	// converting resp to string (interface{} --> string)
	s := resp.(string)

	// Unmarshalling of JSON string into Response struct (string --> Response struct)
	var response Response
	err = json.Unmarshal([]byte(s), &response)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	// Printing on response on terminal
	reply := utils.H{response.Response: req.Name}
	c.JSON(consts.StatusOK, reply)

	klog.Info("HERTZ: Request completed")
}

type Response struct {
	Response string `json:"ResponseBody"`
}
